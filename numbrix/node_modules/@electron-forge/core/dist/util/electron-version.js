"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElectronModulePath = getElectronModulePath;
exports.getElectronVersion = getElectronVersion;
exports.updateElectronDependency = updateElectronDependency;
exports.PackageNotFoundError = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _findUp = _interopRequireDefault(require("find-up"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _yarnOrNpm = _interopRequireWildcard(require("./yarn-or-npm"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:electron-version');
const electronPackageNames = ['electron-prebuilt-compile', 'electron-prebuilt', 'electron-nightly', 'electron'];

function findElectronDep(dep) {
  return electronPackageNames.includes(dep);
}

async function findAncestorNodeModulesPath(dir, packageName) {
  if ((0, _yarnOrNpm.hasYarn)()) {
    const yarnLockPath = await (0, _findUp.default)('yarn.lock', {
      cwd: dir,
      type: 'file'
    });

    if (yarnLockPath) {
      const nodeModulesPath = _path.default.join(_path.default.dirname(yarnLockPath), 'node_modules', packageName);

      if (await _fsExtra.default.pathExists(nodeModulesPath)) {
        return nodeModulesPath;
      }
    }
  }

  return Promise.resolve(undefined);
}

async function determineNodeModulesPath(dir, packageName) {
  const nodeModulesPath = _path.default.join(dir, 'node_modules', packageName);

  if (await _fsExtra.default.pathExists(nodeModulesPath)) {
    return nodeModulesPath;
  }

  return findAncestorNodeModulesPath(dir, packageName);
}

class PackageNotFoundError extends Error {
  constructor(packageName, dir) {
    super(`Cannot find the package "${packageName}". Perhaps you need to run "${(0, _yarnOrNpm.default)()} install" in "${dir}"?`);
  }

}

exports.PackageNotFoundError = PackageNotFoundError;

function getElectronModuleName(packageJSON) {
  if (!packageJSON.devDependencies) {
    throw new Error('package.json for app does not have any devDependencies');
  }

  const packageName = electronPackageNames.find(pkg => packageJSON.devDependencies[pkg]);

  if (packageName === undefined) {
    throw new Error('Could not find any Electron packages in devDependencies');
  }

  return packageName;
}

async function getElectronPackageJSONPath(dir, packageName) {
  const nodeModulesPath = await determineNodeModulesPath(dir, packageName);

  if (!nodeModulesPath) {
    throw new PackageNotFoundError(packageName, dir);
  }

  const electronPackageJSONPath = _path.default.join(nodeModulesPath, 'package.json');

  if (await _fsExtra.default.pathExists(electronPackageJSONPath)) {
    return electronPackageJSONPath;
  }

  return undefined;
}

async function getElectronModulePath(dir, packageJSON) {
  const moduleName = getElectronModuleName(packageJSON);
  const packageJSONPath = await getElectronPackageJSONPath(dir, moduleName);

  if (packageJSONPath) {
    return _path.default.dirname(packageJSONPath);
  }

  return undefined;
}

async function getElectronVersion(dir, packageJSON) {
  const packageName = getElectronModuleName(packageJSON);
  let version = packageJSON.devDependencies[packageName];

  if (!_semver.default.valid(version)) {
    // It's not an exact version, find it in the actual module
    const electronPackageJSONPath = await getElectronPackageJSONPath(dir, packageName);

    if (electronPackageJSONPath) {
      const electronPackageJSON = await _fsExtra.default.readJson(electronPackageJSONPath); // eslint-disable-next-line prefer-destructuring

      version = electronPackageJSON.version;
    } else {
      throw new PackageNotFoundError(packageName, dir);
    }
  }

  return version;
}

function updateElectronDependency(packageJSON, dev, exact) {
  const alteredDev = [].concat(dev);
  let alteredExact = [].concat(exact);

  if (Object.keys(packageJSON.devDependencies).find(findElectronDep)) {
    alteredExact = alteredExact.filter(dep => dep !== 'electron');
  } else {
    const electronKey = Object.keys(packageJSON.dependencies).find(findElectronDep);

    if (electronKey) {
      alteredExact = alteredExact.filter(dep => dep !== 'electron');
      d(`Moving ${electronKey} from dependencies to devDependencies`);
      alteredDev.push(`${electronKey}@${packageJSON.dependencies[electronKey]}`);
      delete packageJSON.dependencies[electronKey];
    }
  }

  return [alteredDev, alteredExact];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2VsZWN0cm9uLXZlcnNpb24udHMiXSwibmFtZXMiOlsiZCIsImVsZWN0cm9uUGFja2FnZU5hbWVzIiwiZmluZEVsZWN0cm9uRGVwIiwiZGVwIiwiaW5jbHVkZXMiLCJmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgiLCJkaXIiLCJwYWNrYWdlTmFtZSIsInlhcm5Mb2NrUGF0aCIsImN3ZCIsInR5cGUiLCJub2RlTW9kdWxlc1BhdGgiLCJwYXRoIiwiam9pbiIsImRpcm5hbWUiLCJmcyIsInBhdGhFeGlzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInVuZGVmaW5lZCIsImRldGVybWluZU5vZGVNb2R1bGVzUGF0aCIsIlBhY2thZ2VOb3RGb3VuZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImdldEVsZWN0cm9uTW9kdWxlTmFtZSIsInBhY2thZ2VKU09OIiwiZGV2RGVwZW5kZW5jaWVzIiwiZmluZCIsInBrZyIsImdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoIiwiZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgiLCJnZXRFbGVjdHJvbk1vZHVsZVBhdGgiLCJtb2R1bGVOYW1lIiwicGFja2FnZUpTT05QYXRoIiwiZ2V0RWxlY3Ryb25WZXJzaW9uIiwidmVyc2lvbiIsInNlbXZlciIsInZhbGlkIiwiZWxlY3Ryb25QYWNrYWdlSlNPTiIsInJlYWRKc29uIiwidXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5IiwiZGV2IiwiZXhhY3QiLCJhbHRlcmVkRGV2IiwiY29uY2F0IiwiYWx0ZXJlZEV4YWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImVsZWN0cm9uS2V5IiwiZGVwZW5kZW5jaWVzIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLGlDQUFOLENBQVY7QUFFQSxNQUFNQyxvQkFBb0IsR0FB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Q0FBSixFQUFvRTtBQUNsRTJDLElBQUFBLFlBQVksR0FBR0EsWUFBWSxDQUFDRyxNQUFiLENBQXFCN0MsR0FBRCxJQUFTQSxHQUFHLEtBQUssVUFBckMsQ0FBZjtBQUNELEdBRkQsTUFFTztBQUNMLFVBQU04QyxXQUFXLEdBQUdILE1BQU0sQ0FBQ0MsSUFBUCxDQUFZdEIsV0FBVyxDQUFDeUIsWUFBeEIsRUFBc0N2QixJQUF0QyxDQUEyQ3pCLGVBQTNDLENBQXBCOztBQUNBLFFBQUkrQyxXQUFKLEVBQWlCO0FBQ2ZKLE1BQUFBLFlBQVksR0FBR0EsWUFBWSxDQUFDRyxNQUFiLENBQXFCN0MsR0FBRCxJQUFTQSxHQUFHLEtBQUssVUFBckMsQ0FBZjtBQUNBSCxNQUFBQSxDQUFDLENBQUUsVUFBU2lELFdBQVksdUNBQXZCLENBQUQ7QUFDQU4sTUFBQUEsVUFBVSxDQUFDUSxJQUFYLENBQWlCLEdBQUVGLFdBQVksSUFBR3hCLFdBQVcsQ0FBQ3lCLFlBQVosQ0FBeUJELFdBQXpCLENBQXNDLEVBQXhFO0FBQ0EsYUFBT3hCLFdBQVcsQ0FBQ3lCLFlBQVosQ0FBeUJELFdBQXpCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sQ0FBQ04sVUFBRCxFQUFhRSxZQUFiLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgZmluZFVwIGZyb20gJ2ZpbmQtdXAnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHlhcm5Pck5wbSwgeyBoYXNZYXJuIH0gZnJvbSAnLi95YXJuLW9yLW5wbSc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6ZWxlY3Ryb24tdmVyc2lvbicpO1xuXG5jb25zdCBlbGVjdHJvblBhY2thZ2VOYW1lcyA9IFtcbiAgJ2VsZWN0cm9uLXByZWJ1aWx0LWNvbXBpbGUnLFxuICAnZWxlY3Ryb24tcHJlYnVpbHQnLFxuICAnZWxlY3Ryb24tbmlnaHRseScsXG4gICdlbGVjdHJvbicsXG5dO1xuXG5mdW5jdGlvbiBmaW5kRWxlY3Ryb25EZXAoZGVwOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGVsZWN0cm9uUGFja2FnZU5hbWVzLmluY2x1ZGVzKGRlcCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmRBbmNlc3Rvck5vZGVNb2R1bGVzUGF0aChcbiAgZGlyOiBzdHJpbmcsXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBpZiAoaGFzWWFybigpKSB7XG4gICAgY29uc3QgeWFybkxvY2tQYXRoID0gYXdhaXQgZmluZFVwKCd5YXJuLmxvY2snLCB7IGN3ZDogZGlyLCB0eXBlOiAnZmlsZScgfSk7XG4gICAgaWYgKHlhcm5Mb2NrUGF0aCkge1xuICAgICAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZSh5YXJuTG9ja1BhdGgpLCAnbm9kZV9tb2R1bGVzJywgcGFja2FnZU5hbWUpO1xuICAgICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMobm9kZU1vZHVsZXNQYXRoKSkge1xuICAgICAgICByZXR1cm4gbm9kZU1vZHVsZXNQYXRoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGV0ZXJtaW5lTm9kZU1vZHVsZXNQYXRoKFxuICBkaXI6IHN0cmluZyxcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkID0gcGF0aC5qb2luKGRpciwgJ25vZGVfbW9kdWxlcycsIHBhY2thZ2VOYW1lKTtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMobm9kZU1vZHVsZXNQYXRoKSkge1xuICAgIHJldHVybiBub2RlTW9kdWxlc1BhdGg7XG4gIH1cbiAgcmV0dXJuIGZpbmRBbmNlc3Rvck5vZGVNb2R1bGVzUGF0aChkaXIsIHBhY2thZ2VOYW1lKTtcbn1cblxuZXhwb3J0IGNsYXNzIFBhY2thZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYWNrYWdlTmFtZTogc3RyaW5nLCBkaXI6IHN0cmluZykge1xuICAgIHN1cGVyKGBDYW5ub3QgZmluZCB0aGUgcGFja2FnZSBcIiR7cGFja2FnZU5hbWV9XCIuIFBlcmhhcHMgeW91IG5lZWQgdG8gcnVuIFwiJHt5YXJuT3JOcG0oKX0gaW5zdGFsbFwiIGluIFwiJHtkaXJ9XCI/YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlY3Ryb25Nb2R1bGVOYW1lKHBhY2thZ2VKU09OOiBhbnkpOiBzdHJpbmcge1xuICBpZiAoIXBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFja2FnZS5qc29uIGZvciBhcHAgZG9lcyBub3QgaGF2ZSBhbnkgZGV2RGVwZW5kZW5jaWVzJyk7XG4gIH1cblxuICBjb25zdCBwYWNrYWdlTmFtZSA9IGVsZWN0cm9uUGFja2FnZU5hbWVzLmZpbmQoKHBrZykgPT4gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzW3BrZ10pO1xuICBpZiAocGFja2FnZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IEVsZWN0cm9uIHBhY2thZ2VzIGluIGRldkRlcGVuZGVuY2llcycpO1xuICB9XG5cbiAgcmV0dXJuIHBhY2thZ2VOYW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRFbGVjdHJvblBhY2thZ2VKU09OUGF0aChcbiAgZGlyOiBzdHJpbmcsXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBub2RlTW9kdWxlc1BhdGggPSBhd2FpdCBkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgoZGlyLCBwYWNrYWdlTmFtZSk7XG4gIGlmICghbm9kZU1vZHVsZXNQYXRoKSB7XG4gICAgdGhyb3cgbmV3IFBhY2thZ2VOb3RGb3VuZEVycm9yKHBhY2thZ2VOYW1lLCBkaXIpO1xuICB9XG5cbiAgY29uc3QgZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGggPSBwYXRoLmpvaW4obm9kZU1vZHVsZXNQYXRoLCAncGFja2FnZS5qc29uJyk7XG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGVsZWN0cm9uUGFja2FnZUpTT05QYXRoKSkge1xuICAgIHJldHVybiBlbGVjdHJvblBhY2thZ2VKU09OUGF0aDtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbGVjdHJvbk1vZHVsZVBhdGgoXG4gIGRpcjogc3RyaW5nLFxuICBwYWNrYWdlSlNPTjogYW55LFxuKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3QgbW9kdWxlTmFtZSA9IGdldEVsZWN0cm9uTW9kdWxlTmFtZShwYWNrYWdlSlNPTik7XG4gIGNvbnN0IHBhY2thZ2VKU09OUGF0aCA9IGF3YWl0IGdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoKGRpciwgbW9kdWxlTmFtZSk7XG4gIGlmIChwYWNrYWdlSlNPTlBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5kaXJuYW1lKHBhY2thZ2VKU09OUGF0aCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlY3Ryb25WZXJzaW9uKGRpcjogc3RyaW5nLCBwYWNrYWdlSlNPTjogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcGFja2FnZU5hbWUgPSBnZXRFbGVjdHJvbk1vZHVsZU5hbWUocGFja2FnZUpTT04pO1xuXG4gIGxldCB2ZXJzaW9uID0gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzW3BhY2thZ2VOYW1lXTtcbiAgaWYgKCFzZW12ZXIudmFsaWQodmVyc2lvbikpIHsgLy8gSXQncyBub3QgYW4gZXhhY3QgdmVyc2lvbiwgZmluZCBpdCBpbiB0aGUgYWN0dWFsIG1vZHVsZVxuICAgIGNvbnN0IGVsZWN0cm9uUGFja2FnZUpTT05QYXRoID0gYXdhaXQgZ2V0RWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgoZGlyLCBwYWNrYWdlTmFtZSk7XG4gICAgaWYgKGVsZWN0cm9uUGFja2FnZUpTT05QYXRoKSB7XG4gICAgICBjb25zdCBlbGVjdHJvblBhY2thZ2VKU09OID0gYXdhaXQgZnMucmVhZEpzb24oZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICB2ZXJzaW9uID0gZWxlY3Ryb25QYWNrYWdlSlNPTi52ZXJzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFja2FnZU5vdEZvdW5kRXJyb3IocGFja2FnZU5hbWUsIGRpcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVFbGVjdHJvbkRlcGVuZGVuY3koXG4gIHBhY2thZ2VKU09OOiBhbnksXG4gIGRldjogc3RyaW5nW10sXG4gIGV4YWN0OiBzdHJpbmdbXSxcbik6IFtzdHJpbmdbXSwgc3RyaW5nW11dIHtcbiAgY29uc3QgYWx0ZXJlZERldiA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KGRldik7XG4gIGxldCBhbHRlcmVkRXhhY3QgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdChleGFjdCk7XG4gIGlmIChPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXMpLmZpbmQoZmluZEVsZWN0cm9uRGVwKSkge1xuICAgIGFsdGVyZWRFeGFjdCA9IGFsdGVyZWRFeGFjdC5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSAnZWxlY3Ryb24nKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlbGVjdHJvbktleSA9IE9iamVjdC5rZXlzKHBhY2thZ2VKU09OLmRlcGVuZGVuY2llcykuZmluZChmaW5kRWxlY3Ryb25EZXApO1xuICAgIGlmIChlbGVjdHJvbktleSkge1xuICAgICAgYWx0ZXJlZEV4YWN0ID0gYWx0ZXJlZEV4YWN0LmZpbHRlcigoZGVwKSA9PiBkZXAgIT09ICdlbGVjdHJvbicpO1xuICAgICAgZChgTW92aW5nICR7ZWxlY3Ryb25LZXl9IGZyb20gZGVwZW5kZW5jaWVzIHRvIGRldkRlcGVuZGVuY2llc2ApO1xuICAgICAgYWx0ZXJlZERldi5wdXNoKGAke2VsZWN0cm9uS2V5fUAke3BhY2thZ2VKU09OLmRlcGVuZGVuY2llc1tlbGVjdHJvbktleV19YCk7XG4gICAgICBkZWxldGUgcGFja2FnZUpTT04uZGVwZW5kZW5jaWVzW2VsZWN0cm9uS2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2FsdGVyZWREZXYsIGFsdGVyZWRFeGFjdF07XG59XG4iXX0=